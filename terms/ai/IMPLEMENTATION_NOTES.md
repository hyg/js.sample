# 智能条款系统 - 实现笔记与经验总结

本文档总结了在实现智能条款系统过程中遇到的问题、解决方案以及相关的开发经验和建议。

---

## 1. ID 生成与引用

### 问题
初始实现中，条款 ID 的生成策略不够明确，特别是对于复合条款。同时，父子条款之间的引用方式未遵循“使用 ID 引用子条款”的核心要求。

### 解决方案
- **ID 生成**：
    - **文本条款**：严格按照需求，使用条款正文（`text`）的 SHA256 哈希值的前八位作为 ID。这确保了内容唯一性。
    - **复合条款**：由于没有单一的“正文”，其 ID 基于其子条款定义结构（`subClauses` 数组）的序列化字符串的 SHA256 哈希前八位生成。这提供了一种基于结构的唯一标识。
- **引用方式**：在复合条款的 `subClauses` 数组中，每个子条款条目仅通过其 `id` 字段进行引用。系统通过一个全局注册表 (`globalClauseRegistry`) 来解析这些 ID 并获取实际的子条款对象。

### 需求文档改进建议
- 明确区分文本条款和复合条款的 ID 生成规则。对于复合条款，应指定是基于其包含的子条款 ID、结构还是其他方式。
- 明确指出父子条款间的关系是通过“ID”建立的，而非直接对象引用或名称引用。

### 持久记忆要点 (可写入 `.qwen\QWEN.md`)
- **强制 ID 引用**：在设计具有层级或关联关系的数据模型时，若要求通过 ID 引用其他实体，应在代码中严格遵守此规则。避免使用对象引用或名称引用，以确保数据结构的清晰性和可序列化性。
- **ID 生成策略**：
    - 对于基于内容的实体（如文本条款），使用内容的哈希值（如 SHA256 前 N 位）作为 ID 是一种保证唯一性的好方法。
    - 对于聚合实体（如复合条款），其 ID 可基于其组成部分的结构或 ID 的组合来生成，以反映其构成。

---

## 2. 子条款定义结构 ("每个子条款明确")

### 问题
需求中提到“每个子条款明确”，但在初始实现中，子条款的定义不够详细，缺少了 `index`、`mapping` 覆盖和 `numberPrefix` 等关键属性。

### 解决方案
- 修改 `Clause` 类的构造函数，将 `data.subClauses` 定义为一个对象数组，每个对象包含：
    - `id` (string): 子条款的唯一标识符。
    - `index` (number/string): 该子条款在父条款中的排序序号，支持复杂序号（如 "2.1", "3.a.ii"）。
    - `mapping` (Object, 可选): 一个映射表，用于覆盖子条款自身映射表中的占位符，实现上下文相关的脱敏。
    - `numberPrefix` (string, 可选): 添加到子条款内容前的序号前缀字符串（如 "Ⅰ.", "一、", "⑴"）。

### 需求文档改进建议
- 应更详细地描述复合条款的结构，明确指出 `subClauses` 是一个包含 `id`, `index`, `mapping`, `numberPrefix` 等字段的对象列表，而不仅仅是一个 ID 列表。

### 持久记忆要点
- **复杂数据结构定义**：当需求描述一个对象包含“另一个对象的列表”时，应进一步细化列表中每个元素的具体结构和属性，避免歧义。
- **序号与前缀分离**：区分“用于排序的内部索引 (`index`)" 和 “用于显示的格式化前缀 (`numberPrefix`)” 是设计灵活编号系统的关键。

---

## 3. 内容语言与结构要求

### 问题
测试数据未满足“正文和备注都改为中文”以及“每个组合条款包含至少三个子条款”的要求。同时，父条款指定子条款序号的方式也需要支持更复杂的格式。

### 解决方案
- 在生成测试数据的脚本 (`generateMainTest.js`, `generateNestedTest.js`) 中，将所有 `text` 和 `readme` 字段更新为中文。
- 确保所有复合条款在创建时都至少包含三个子条款定义。
- 在子条款定义中，`index` 字段被设置为数字、字母或符号的组合（例如 `"2.1"`, `3`, `"3.a.1"`），以满足复杂序号的需求。

### 需求文档改进建议
- 对于涉及示例数据的需求，应尽可能明确数据的语言、结构（如子条款数量）和格式要求（如序号类型），以便一次性正确实现。

### 持久记忆要点
- **测试数据质量**：高质量的测试数据应尽可能覆盖需求的所有方面，包括语言、结构、边界条件等，以确保实现的完整性。
- **国际化考量**：在设计处理文本的系统时，应从一开始就考虑对多语言（尤其是中文等非拉丁字符）的支持，并在测试中加以验证。

---

## 4. "修订程序" 字段

### 问题
需求中明确了“修订程序，由一个条款的id表示”，但此字段未在初始的 `Clause` 类中得到体现。

### 解决方案
- 在 `Clause` 类的构造函数中添加 `revisionProcessId` 属性。
- 在生成测试数据时，为部分条款（如根条款、简单条款）显式赋值该属性。
- 在 `toMarkdown` 和 `toHtml` 输出方法中添加对该字段的显示支持。

### 需求文档改进建议
- 对于数据模型中的每个字段，都应在需求文档中明确其含义、数据类型和可选性。

### 持久记忆要点
- **数据模型完整性**：实现数据模型时，应确保所有需求中提及的字段都被正确地映射到代码中，即使是可选字段。
- **元数据输出**：在生成文档或报告时，考虑将对象的所有相关元数据（如 ID, Readme, Revision Process ID）一并输出，以提供完整信息。

---

## 5. Markdown 与 HTML 输出格式

### 问题
- **Markdown**: 条款之间的分隔不够清晰，空行也被错误地添加了序号前缀。
- **HTML**: 序号前缀使用了 Markdown 的 `**` 语法进行加粗，这在 HTML 中是不正确的。

### 解决方案
- **Markdown**:
    - 在 `generateContent` 方法中，重构了内容拼接逻辑。将每个子条款的内容作为独立部分处理，最后使用 `\n\n` (段落分隔) 将它们连接起来，确保条款间有清晰的空行。
    - 在为子条款内容添加序号前缀时，先按 `\n` 分割行，然后只对非空行添加前缀。这防止了空行被错误地标记。
- **HTML**:
    - 在 `toHtml` 方法中，使用 CSS 类 `.number-prefix { font-weight: bold; }` 来定义序号前缀的样式。
    - 更新了用于包裹序号前缀的正则表达式，确保它能正确识别并包裹“行首至第一个空格前”的部分，并将其余内容保留，生成 `<span class="number-prefix">前缀 </span>其余内容` 的格式。

### 需求文档改进建议
- 对于输出格式，可以更具体地说明期望的视觉效果，例如“条款间应有空行分隔”、“序号应加粗显示”等，并最好能提供简短的示例。

### 持久记忆要点
- **输出格式与内容分离**：在生成内容 (`generateContent`) 和格式化输出 (`toMarkdown`, `toHtml`) 之间保持清晰的职责分离。`generateContent` 应专注于逻辑内容，而格式化方法负责将其转换为特定格式。
- **正则表达式谨慎使用**：处理文本格式（尤其是行内标记）时，正则表达式非常强大但也容易出错。务必仔细测试边界情况（如空行、行尾无空格等）。
- **HTML/CSS 最佳实践**：在 HTML 中应用样式应通过 CSS 类或内联样式，而不是使用 Markdown 语法。确保生成的 HTML 结构清晰且语义正确。